<!DOCTYPE html>
<html>
<head>
    <title>Configurable Bouncing Ball Simulation</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #333;
            margin: 20px;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 800px;
            padding: 10px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            background: #222;
            padding: 10px;
            border-radius: 5px;
        }
        label {
            margin: 5px 0;
        }
        input[type="range"] {
            width: 150px;
        }
        button {
            background: #444;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #666;
        }
        button.active {
            background: #833;
        }
        input[type="file"] {
            max-width: 150px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <label>Ball Speed: <span id="speedValue">1</span>x</label>
            <input type="range" id="speedControl" min="0.1" max="10" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label>Trail Enabled:</label>
            <input type="checkbox" id="trailToggle">
        </div>
        <div class="control-group">
            <label>Trail Interval: <span id="intervalValue">100</span>ms</label>
            <input type="range" id="intervalControl" min="10" max="500" step="10" value="100">
        </div>
        <div class="control-group">
            <label>Max Trail Length: <span id="maxTrailValue">100</span></label>
            <input type="range" id="maxTrailControl" min="10" max="1000" step="10" value="100">
        </div>
        <div class="control-group">
            <label>Sound Enabled:</label>
            <input type="checkbox" id="soundToggle">
            <label>Sound Volume: <span id="volumeValue">50</span>%</label>
            <input type="range" id="volumeControl" min="0" max="100" step="1" value="50">
            <label>Custom Sound:</label>
            <input type="file" id="soundFileInput" accept="audio/*">
        </div>
        <div class="control-group">
            <button id="pauseButton">Pause</button>
            <button id="clearTrailsButton">Clear Trails</button>
            <button id="restartButton">Restart Simulation</button>
        </div>
        <div class="control-group">
            <label>Recording Duration: <span id="recordingDurationValue">60</span>s</label>
            <input type="range" id="recordingDurationControl" min="5" max="300" step="5" value="60">
            <label>
                <input type="checkbox" id="restartOnRecord" checked>
                Restart on Recording
            </label>
            <button id="recordButton">Start Recording</button>
            <div id="recordingTimer">Recording: 0:00</div>
        </div>
    </div>
    <canvas id="canvas" width="800" height="800"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Audio context and sound setup
        let audioContext = null;
        let customSound = null;
        let defaultSound = null;

        // Initialize audio context on user interaction
        document.addEventListener('click', initAudio, { once: true });

        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            // Create default bounce sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            
            oscillator.start();
            defaultSound = { oscillator, gainNode };
        }

        // Sound file handling
        const soundFileInput = document.getElementById('soundFileInput');
        soundFileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    customSound = audioBuffer;
                } catch (error) {
                    console.error('Error loading sound file:', error);
                    alert('Error loading sound file. Please try another file.');
                }
            }
        });

        // Sound controls
        const soundToggle = document.getElementById('soundToggle');
        const volumeControl = document.getElementById('volumeControl');
        const volumeValue = document.getElementById('volumeValue');

        volumeControl.oninput = () => {
            volumeValue.textContent = volumeControl.value;
        };

        function playBounceSound() {
            if (!soundToggle.checked || !audioContext) return;

            const volume = parseInt(volumeControl.value) / 100;

            if (customSound) {
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                source.buffer = customSound;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                gainNode.gain.value = volume;
                source.start();
            } else {
                // Play default sound
                const { gainNode } = defaultSound;
                gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            }
        }

        // Configuration
        const ringRadius = 380;
        const ballRadius = 15;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        // Controls
        const speedControl = document.getElementById('speedControl');
        const speedValue = document.getElementById('speedValue');
        const trailToggle = document.getElementById('trailToggle');
        const intervalControl = document.getElementById('intervalControl');
        const intervalValue = document.getElementById('intervalValue');
        const maxTrailControl = document.getElementById('maxTrailControl');
        const maxTrailValue = document.getElementById('maxTrailValue');
        const pauseButton = document.getElementById('pauseButton');
        const clearTrailsButton = document.getElementById('clearTrailsButton');

        // Simulation state
        let isPaused = false;
        let animationFrameId = null;

        // Update display values
        speedControl.oninput = () => speedValue.textContent = speedControl.value;
        intervalControl.oninput = () => intervalValue.textContent = intervalControl.value;
        maxTrailControl.oninput = () => maxTrailValue.textContent = maxTrailControl.value;

        // Pause button handler
        pauseButton.onclick = () => {
            isPaused = !isPaused;
            pauseButton.textContent = isPaused ? "Resume" : "Pause";
            pauseButton.classList.toggle('active');
            if (!isPaused) {
                lastTime = Date.now();
                animate();
            } else if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        };

        // Clear trails button handler
        clearTrailsButton.onclick = () => {
            trailBalls = [];
        };

        // Physics constants
        const gravity = 0.5;
        const elasticity = 1;

        // Color cycling configuration
        let colorPhase = 0;
        const colorSpeed = 0.005;

        // Trail system
        let trailBalls = [];
        let lastTrailTime = 0;
        let lastTime = Date.now();

        function getCurrentColor() {
            const r = Math.sin(colorPhase) * 127 + 128;
            const g = Math.sin(colorPhase + (2 * Math.PI / 3)) * 127 + 128;
            const b = Math.sin(colorPhase + (4 * Math.PI / 3)) * 127 + 128;
            return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }

        // Ball properties
        let ball = {
            x: centerX,
            y: centerY - 300,
            vx: 3,
            vy: 0,
            radius: ballRadius,
            initialTotalEnergy: 0
        };

        function distanceFromCenter(x, y) {
            const dx = x - centerX;
            const dy = y - centerY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function normalizeVector(x, y) {
            const length = Math.sqrt(x * x + y * y);
            return { x: x / length, y: y / length };
        }

        function calculateTotalEnergy(y, vx, vy) {
            const kinetic = 0.5 * (vx * vx + vy * vy);
            const potential = gravity * (canvas.height - y);
            return kinetic + potential;
        }

        ball.initialTotalEnergy = calculateTotalEnergy(ball.y, ball.vx, ball.vy);

        function addTrailBall() {
            const currentColor = getCurrentColor();
            trailBalls.push({
                x: ball.x,
                y: ball.y,
                color: currentColor,
                timestamp: Date.now()
            });

            const maxTrail = parseInt(maxTrailControl.value);
            if (trailBalls.length > maxTrail) {
                trailBalls = trailBalls.slice(-maxTrail);
            }
        }

        function update() {
            const currentTime = Date.now();
            const deltaTime = (currentTime - lastTime) / 16.67; // Normalize to 60 FPS
            lastTime = currentTime;

            // Update color phase
            colorPhase += colorSpeed;
            if (colorPhase > Math.PI * 2) {
                colorPhase -= Math.PI * 2;
            }

            const speedMultiplier = parseFloat(speedControl.value) * deltaTime;

            // Apply gravity
            ball.vy += gravity * speedMultiplier;

            // Update position
            ball.x += ball.vx * speedMultiplier;
            ball.y += ball.vy * speedMultiplier;

            // Handle trail creation
            if (trailToggle.checked) {
                const now = Date.now();
                const interval = parseInt(intervalControl.value);
                if (now - lastTrailTime >= interval) {
                    addTrailBall();
                    lastTrailTime = now;
                }
            }

            // Check collision with ring
            const distanceToCenter = distanceFromCenter(ball.x, ball.y);
            if (distanceToCenter + ball.radius > ringRadius) {
                // Play bounce sound
                playBounceSound();

                const dx = ball.x - centerX;
                const dy = ball.y - centerY;
                const normal = normalizeVector(dx, dy);

                const overlap = distanceToCenter + ball.radius - ringRadius;
                ball.x -= normal.x * overlap;
                ball.y -= normal.y * overlap;

                const dotProduct = ball.vx * normal.x + ball.vy * normal.y;
                ball.vx = (ball.vx - 2 * dotProduct * normal.x) * elasticity;
                ball.vy = (ball.vy - 2 * dotProduct * normal.y) * elasticity;

                const currentTotalEnergy = calculateTotalEnergy(ball.y, ball.vx, ball.vy);
                
                if (Math.abs(currentTotalEnergy - ball.initialTotalEnergy) > 0.1) {
                    const currentPotential = gravity * (canvas.height - ball.y);
                    const targetKinetic = ball.initialTotalEnergy - currentPotential;
                    const currentKinetic = 0.5 * (ball.vx * ball.vx + ball.vy * ball.vy);
                    
                    if (currentKinetic > 0) {
                        const scaleFactor = Math.sqrt(targetKinetic / currentKinetic);
                        ball.vx *= scaleFactor;
                        ball.vy *= scaleFactor;
                    }
                }
            }
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw ring
            ctx.beginPath();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Draw trail balls
            trailBalls.forEach((trailBall, index) => {
                ctx.beginPath();
                const alpha = 0.5 * (index / trailBalls.length);
                ctx.fillStyle = trailBall.color.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
                ctx.arc(trailBall.x, trailBall.y, ballRadius, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw main ball
            ctx.beginPath();
            ctx.fillStyle = getCurrentColor();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();

            // Draw pause indicator
            if (isPaused) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', centerX, 40);
            }
        }

        function animate() {
            if (!isPaused) {
                update();
                draw();
                animationFrameId = requestAnimationFrame(animate);
            }
        }

        // Start animation
        animate();

        const recordButton = document.getElementById('recordButton');
        const recordingDurationControl = document.getElementById('recordingDurationControl');
        const recordingDurationValue = document.getElementById('recordingDurationValue');
        const recordingTimer = document.getElementById('recordingTimer');
        
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = 0;
        let recordingInterval = null;

        recordingDurationControl.oninput = () => {
            recordingDurationValue.textContent = recordingDurationControl.value;
        };

        function updateRecordingTimer() {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            recordingTimer.textContent = `Recording: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function startRecording() {
            if (restartOnRecord.checked) {
                resetBall();
            }
            recordedChunks = [];
            const stream = canvas.captureStream();
            
            // If audio context exists and sound is enabled, add audio track
            if (audioContext && soundToggle.checked) {
                const audioDestination = audioContext.createMediaStreamDestination();
                if (defaultSound) {
                    defaultSound.gainNode.connect(audioDestination);
                }
                const audioTracks = audioDestination.stream.getAudioTracks();
                audioTracks.forEach(track => stream.addTrack(track));
            }

            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9'
            });

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, {
                    type: 'video/webm'
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ball-simulation.webm';
                a.click();
                URL.revokeObjectURL(url);
                
                // Reset UI
                recordButton.textContent = 'Start Recording';
                recordButton.classList.remove('recording');
                recordingTimer.style.display = 'none';
                clearInterval(recordingInterval);
            };

            // Start recording
            recordingStartTime = Date.now();
            mediaRecorder.start();
            recordButton.textContent = 'Stop Recording';
            recordButton.classList.add('recording');
            recordingTimer.style.display = 'block';
            
            // Start timer update
            recordingInterval = setInterval(updateRecordingTimer, 1000);

            // Stop recording after duration
            const duration = parseInt(recordingDurationControl.value) * 1000;
            setTimeout(() => {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
            }, duration);
        }

        recordButton.onclick = () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            } else {
                startRecording();
            }
        };
        // Add mouse interaction
        canvas.addEventListener('click', (e) => {
            if (!isPaused) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                ball.vx = (x - ball.x) * 0.2;
                ball.vy = (y - ball.y) * 0.2;
                
                ball.initialTotalEnergy = calculateTotalEnergy(ball.y, ball.vx, ball.vy);
            }
        });
        const restartButton = document.getElementById('restartButton');
        const restartOnRecord = document.getElementById('restartOnRecord');

        function resetBall() {
            ball = {
                x: centerX,
                y: centerY - 300,
                vx: 3,
                vy: 0,
                radius: ballRadius,
                initialTotalEnergy: 0
            };
            ball.initialTotalEnergy = calculateTotalEnergy(ball.y, ball.vx, ball.vy);
            trailBalls = [];
        }

        restartButton.onclick = () => {
            resetBall();
        };
    </script>
</body>
</html>