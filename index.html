<!DOCTYPE html>
<html>
<head>
    <title>Configurable Bouncing Ball Simulation</title>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #333;
            margin: 20px;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 800px;
            padding: 10px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            background: #222;
            padding: 10px;
            border-radius: 5px;
        }
        label {
            margin: 5px 0;
        }
        input[type="range"] {
            width: 150px;
        }
        button {
            background: #444;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #666;
        }
        button.active {
            background: #833;
        }
        input[type="file"] {
            max-width: 150px;
        }

        .canvas-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .preset-dimensions {
            display: flex;
            gap: 15px;
        }
        .custom-dimensions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .custom-dimensions input[type="number"] {
            width: 80px;
            background: #333;
            border: 1px solid #444;
            color: white;
            padding: 4px;
            border-radius: 4px;
        }
        .dimension-type {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-group">
            <label>Ball Speed: <span id="speedValue">1</span>x</label>
            <input type="range" id="speedControl" min="0.1" max="10" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label>Trail Enabled:</label>
            <input type="checkbox" id="trailToggle">
        </div>
        <div class="control-group">
            <label>Trail Interval: <span id="intervalValue">100</span>ms</label>
            <input type="range" id="intervalControl" min="10" max="500" step="10" value="100">
        </div>
        <div class="control-group">
            <label>Max Trail Length: <span id="maxTrailValue">100</span></label>
            <input type="range" id="maxTrailControl" min="10" max="1000" step="10" value="100">
        </div>
        <div class="control-group">
            <label>Sound Enabled:</label>
            <input type="checkbox" checked="true" id="soundToggle">
            <label>Sound Volume: <span id="volumeValue">50</span>%</label>
            <input type="range" id="volumeControl" min="0" max="100" step="1" value="50">
            <label>Custom Sound:</label>
            <input type="file" id="soundFileInput" accept="audio/*">
        </div>
        <div class="control-group">
            <button id="pauseButton" class="active">Resume</button>
            <button id="clearTrailsButton">Clear Trails</button>
            <button id="clearLinesButton">Clear Lines</button>
            <button id="clearAllButton">Clear All</button>
            <button id="restartButton">Restart Simulation</button>
        </div>
        <div class="control-group">
            <label>Recording Duration: <span id="recordingDurationValue">60</span>s</label>
            <input type="range" id="recordingDurationControl" min="5" max="300" step="5" value="60">
            <label>
                <input type="checkbox" id="restartOnRecord" checked>
                Restart on Recording
            </label>
            <button id="recordButton">Start Recording</button>
            <div id="recordingTimer">Recording: 0:00</div>
        </div>
        <div class="control-group">
            <div class="direction-controls">
                <label>Initial Direction:</label>
                <select id="directionMode">
                    <option value="fixed">Fixed</option>
                    <option value="random">Random</option>
                </select>
            </div>
            <label>Initial Speed: <span id="initialSpeedValue">1</span></label>
            <input type="range" id="initialSpeedControl" min="0.1" max="10" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label>Collision Lines:</label>
            <input type="checkbox" id="linesToggle" checked>
            <label>Max Lines: <span id="maxLinesValue">100</span></label>
            <input type="range" id="maxLinesControl" min="10" max="500" step="10" value="100">
            <label>Line Duration: <span id="lineDurationValue">20</span>s</label>
            <input type="range" id="lineDurationControl" min="0.5" max="60" step="1" value="20">
        </div>
        <div class="control-group">
            <label>Number of Balls: <span id="ballCountValue">1</span></label>
            <input type="range" id="ballCountControl" min="1" max="20" step="1" value="1">
            <label>
                <input type="checkbox" id="ballCollisionToggle">
                Enable Ball Collisions
            </label>
        </div>
    </div>
    <canvas id="canvas" width="800" height="800"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const directionMode = document.getElementById('directionMode');
        const initialSpeedControl = document.getElementById('initialSpeedControl');
        const initialSpeedValue = document.getElementById('initialSpeedValue');

        initialSpeedControl.oninput = () => {
            initialSpeedValue.textContent = initialSpeedControl.value;
        };
        let audioContext = null;
        let customSound = null;
        let defaultSound = null;
        
        document.addEventListener('click', initAudio, { once: true });

        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            
            oscillator.start();
            defaultSound = { oscillator, gainNode };
        }

        const soundFileInput = document.getElementById('soundFileInput');
        soundFileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    customSound = audioBuffer;
                } catch (error) {
                    console.error('Error loading sound file:', error);
                    alert('Error loading sound file. Please try another file.');
                }
            }
        });

        const soundToggle = document.getElementById('soundToggle');
        const volumeControl = document.getElementById('volumeControl');
        const volumeValue = document.getElementById('volumeValue');

        volumeControl.oninput = () => {
            volumeValue.textContent = volumeControl.value;
        };

        function playBounceSound() {
            if (!soundToggle.checked || !audioContext) return;

            const volume = parseInt(volumeControl.value) / 100;

            if (customSound) {
                const source = audioContext.createBufferSource();
                const gainNode = audioContext.createGain();
                source.buffer = customSound;
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                gainNode.gain.value = volume;
                source.start();
            } else {
                const { gainNode } = defaultSound;
                gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            }
        }

        const ringRadius = 380;
        const ballRadius = 15;
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        const linesToggle = document.getElementById('linesToggle');
        const maxLinesControl = document.getElementById('maxLinesControl');
        const maxLinesValue = document.getElementById('maxLinesValue');
        const lineDurationControl = document.getElementById('lineDurationControl');
        const lineDurationValue = document.getElementById('lineDurationValue');

        maxLinesControl.oninput = () => maxLinesValue.textContent = maxLinesControl.value;
        lineDurationControl.oninput = () => lineDurationValue.textContent = lineDurationControl.value;

        let collisionLines = [];

        function addCollisionLine(x, y, color, ball) {  
            if (!linesToggle.checked) return;
            
            collisionLines.push({
                startX: x,
                startY: y,
                endX: x,
                endY: y,
                color: color,
                timestamp: Date.now(),
                duration: parseFloat(lineDurationControl.value) * 1000,
                ball: ball  
            });

            const maxLines = parseInt(maxLinesControl.value);
            if (collisionLines.length > maxLines) {
                collisionLines.shift();
            }
        }

        function updateLines() {
            const currentTime = Date.now();
            collisionLines = collisionLines.filter(line => {
                const age = currentTime - line.timestamp;
                return age < line.duration;
            });

            collisionLines.forEach(line => {
                line.endX = line.ball.x;
                line.endY = line.ball.y;
            });
        }
        const speedControl = document.getElementById('speedControl');
        const speedValue = document.getElementById('speedValue');
        const trailToggle = document.getElementById('trailToggle');
        const intervalControl = document.getElementById('intervalControl');
        const intervalValue = document.getElementById('intervalValue');
        const maxTrailControl = document.getElementById('maxTrailControl');
        const maxTrailValue = document.getElementById('maxTrailValue');
        const pauseButton = document.getElementById('pauseButton');
        const clearTrailsButton = document.getElementById('clearTrailsButton');
        const clearLinesButton = document.getElementById('clearLinesButton');
        const clearAllButton = document.getElementById('clearAllButton');

        clearLinesButton.onclick = () => {
            collisionLines = [];
        };

        clearAllButton.onclick = () => {
            balls.forEach(ball => {
                ball.trails = [];
            });
            collisionLines = [];
        };
        let isPaused = true;
        let animationFrameId = null;

        speedControl.oninput = () => speedValue.textContent = speedControl.value;
        intervalControl.oninput = () => intervalValue.textContent = intervalControl.value;
        maxTrailControl.oninput = () => maxTrailValue.textContent = maxTrailControl.value;

        pauseButton.onclick = () => {
            isPaused = !isPaused;
            pauseButton.textContent = isPaused ? "Resume" : "Pause";
            pauseButton.classList.toggle('active');
            if (!isPaused) {
                lastTime = Date.now();
                animate();
            } else if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        };

        clearTrailsButton.onclick = () => {
            balls.forEach(ball => {
                ball.trails = [];
            });
        };

        const gravity = 0.5;
        const elasticity = 1;

        let colorPhase = 0;
        const colorSpeed = 0.005;

        let trailBalls = [];
        let lastTrailTime = 0;
        let lastTime = Date.now();

        function getCurrentColor() {
            const r = Math.sin(colorPhase) * 127 + 128;
            const g = Math.sin(colorPhase + (2 * Math.PI / 3)) * 127 + 128;
            const b = Math.sin(colorPhase + (4 * Math.PI / 3)) * 127 + 128;
            return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }

        let balls = [];
        function checkBallCollision(ball1, ball2) {
            const dx = ball2.x - ball1.x;
            const dy = ball2.y - ball1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (ball1.radius + ball2.radius);
        }

        function resolveBallCollision(ball1, ball2) {
            const dx = ball2.x - ball1.x;
            const dy = ball2.y - ball1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance === 0) {
                ball2.x += ball2.radius * 0.1;
                ball2.y += ball2.radius * 0.1;
                return;
            }

            const normal = { 
                x: dx / distance, 
                y: dy / distance 
            };

            const relativeVelocityX = ball2.vx - ball1.vx;
            const relativeVelocityY = ball2.vy - ball1.vy;
            
            const velocityAlongNormal = relativeVelocityX * normal.x + relativeVelocityY * normal.y;
            
            if (velocityAlongNormal > 0) {
                return;
            }

            const restitution = elasticity;

            const overlap = (ball1.radius + ball2.radius) - distance;
            const percent = 0.8;
            const correction = (overlap / 2) * percent;
            
            ball1.x -= normal.x * correction;
            ball1.y -= normal.y * correction;
            ball2.x += normal.x * correction;
            ball2.y += normal.y * correction;

            const impulseMagnitude = -(1 + restitution) * velocityAlongNormal;
            const totalMass = 2; 

            const impulse = {
                x: normal.x * (impulseMagnitude / totalMass),
                y: normal.y * (impulseMagnitude / totalMass)
            };

            ball1.vx -= impulse.x;
            ball1.vy -= impulse.y;
            ball2.vx += impulse.x;
            ball2.vy += impulse.y;

            ball1.initialTotalEnergy = calculateTotalEnergy(ball1.y, ball1.vx, ball1.vy);
            ball2.initialTotalEnergy = calculateTotalEnergy(ball2.y, ball2.vx, ball2.vy);
        }
        function distanceFromCenter(x, y) {
            const dx = x - centerX;
            const dy = y - centerY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function normalizeVector(x, y) {
            const length = Math.sqrt(x * x + y * y);
            return { x: x / length, y: y / length };
        }

        function calculateTotalEnergy(y, vx, vy) {
            const kinetic = 0.5 * (vx * vx + vy * vy);
            const potential = gravity * (canvas.height - y);
            return kinetic + potential;
        }

        function addTrailBall() {
            const currentColor = getCurrentColor();
            trailBalls.push({
                x: ball.x,
                y: ball.y,
                color: currentColor,
                timestamp: Date.now()
            });

            const maxTrail = parseInt(maxTrailControl.value);
            if (trailBalls.length > maxTrail) {
                trailBalls = trailBalls.slice(-maxTrail);
            }
        }
        function update() {
            const currentTime = Date.now();
            const deltaTime = (currentTime - lastTime) / 16.67;
            lastTime = currentTime;

            colorPhase += colorSpeed;
            if (colorPhase > Math.PI * 2) {
                colorPhase -= Math.PI * 2;
            }

            const speedMultiplier = parseFloat(speedControl.value) * deltaTime;
            const ballCollisionEnabled = document.getElementById('ballCollisionToggle').checked;

            balls.forEach(ball => {
                ball.vy += gravity * speedMultiplier;
                ball.x += ball.vx * speedMultiplier;
                ball.y += ball.vy * speedMultiplier;
                ball.color = getCurrentColor();

                if (trailToggle.checked) {
                    const now = Date.now();
                    const interval = parseInt(intervalControl.value);
                    if (now - lastTrailTime >= interval) {
                        ball.trails = ball.trails || [];
                        ball.trails.push({
                            x: ball.x,
                            y: ball.y,
                            color: ball.color,
                            timestamp: now
                        });

                        const maxTrail = parseInt(maxTrailControl.value);
                        if (ball.trails.length > maxTrail) {
                            ball.trails = ball.trails.slice(-maxTrail);
                        }
                    }
                }

                const distanceToCenter = distanceFromCenter(ball.x, ball.y);
                if (distanceToCenter + ball.radius > ringRadius) {
                    playBounceSound();

                    const dx = ball.x - centerX;
                    const dy = ball.y - centerY;
                    const normal = normalizeVector(dx, dy);

                    addCollisionLine(
                        ball.x - normal.x * ball.radius,
                        ball.y - normal.y * ball.radius,
                        ball.color,
                        ball
                    );

                    // Move ball back to ring boundary
                    const overlap = distanceToCenter + ball.radius - ringRadius;
                    ball.x -= normal.x * overlap;
                    ball.y -= normal.y * overlap;

                    // Calculate reflection
                    const dotProduct = ball.vx * normal.x + ball.vy * normal.y;
                    ball.vx = ball.vx - 2 * dotProduct * normal.x;
                    ball.vy = ball.vy - 2 * dotProduct * normal.y;

                    if (!ball.hasCollidedWithWall) {
                        ball.vx *= 1.5;
                        ball.vy *= 1.5;
                        ball.hasCollidedWithWall = true;
                        ball.initialTotalEnergy = calculateTotalEnergy(ball.y, ball.vx, ball.vy);
                    }

                    // Ensure energy conservation
                    const currentEnergy = calculateTotalEnergy(ball.y, ball.vx, ball.vy);
                    if (Math.abs(currentEnergy - ball.initialTotalEnergy) > 0.1) {
                        const energyRatio = Math.sqrt(ball.initialTotalEnergy / currentEnergy);
                        const velocity = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
                        const angle = Math.atan2(ball.vy, ball.vx);
                        ball.vx = Math.cos(angle) * velocity * energyRatio;
                        ball.vy = Math.sin(angle) * velocity * energyRatio;
                    }
                }
            });

            // Ball collision handling with energy preservation
            if (ballCollisionEnabled) {
                for (let i = 0; i < balls.length; i++) {
                    for (let j = i + 1; j < balls.length; j++) {
                        if (!balls[i] || !balls[j]) continue;
                        
                        if (checkBallCollision(balls[i], balls[j])) {
                            const totalEnergyBefore = 
                                calculateTotalEnergy(balls[i].y, balls[i].vx, balls[i].vy) +
                                calculateTotalEnergy(balls[j].y, balls[j].vx, balls[j].vy);

                            resolveBallCollision(balls[i], balls[j]);
                            playBounceSound();

                            // Ensure total energy is conserved after collision
                            const totalEnergyAfter = 
                                calculateTotalEnergy(balls[i].y, balls[i].vx, balls[i].vy) +
                                calculateTotalEnergy(balls[j].y, balls[j].vx, balls[j].vy);

                            const energyRatio = Math.sqrt(totalEnergyBefore / totalEnergyAfter);
                            balls[i].vx *= energyRatio;
                            balls[i].vy *= energyRatio;
                            balls[j].vx *= energyRatio;
                            balls[j].vy *= energyRatio;
                        }
                    }
                }
            }

            updateLines();
            if (trailToggle.checked) {
                lastTrailTime = currentTime;
            }
        }

        function draw() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            collisionLines.forEach(line => {
                const age = Date.now() - line.timestamp;
                const alpha = 1 - (age / line.duration);
                ctx.beginPath();
                ctx.strokeStyle = line.color.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
                ctx.lineWidth = 2;
                ctx.moveTo(line.startX, line.startY);
                ctx.lineTo(line.endX, line.endY);
                ctx.stroke();
            });

            ctx.beginPath();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
            ctx.stroke();

            balls.forEach(ball => {
                if (ball.trails) {
                    ball.trails.forEach((trailBall, index) => {
                        ctx.beginPath();
                        const alpha = 0.5 * (index / ball.trails.length);
                        ctx.fillStyle = trailBall.color.replace('rgb', 'rgba').replace(')', `, ${alpha})`);
                        ctx.arc(trailBall.x, trailBall.y, ballRadius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
            });

            // Draw balls
            balls.forEach(ball => {
                ctx.beginPath();
                ctx.fillStyle = ball.color;
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            if (isPaused) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', centerX, 40);
            }
        }

        const ballCountControl = document.getElementById('ballCountControl');
        const ballCountValue = document.getElementById('ballCountValue');

        ballCountControl.oninput = () => {
            ballCountValue.textContent = ballCountControl.value;
            resetBalls();
        };

        function animate() {
            if (!isPaused) {
                update();
                draw();
                animationFrameId = requestAnimationFrame(animate);
            }
        }

        animate();

        const recordButton = document.getElementById('recordButton');
        const recordingDurationControl = document.getElementById('recordingDurationControl');
        const recordingDurationValue = document.getElementById('recordingDurationValue');
        const recordingTimer = document.getElementById('recordingTimer');
        
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = 0;
        let recordingInterval = null;

        recordingDurationControl.oninput = () => {
            recordingDurationValue.textContent = recordingDurationControl.value;
        };

        function updateRecordingTimer() {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            recordingTimer.textContent = `Recording: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function startRecording() {
            if (restartOnRecord.checked) {
                resetBalls();
            }
            recordedChunks = [];
            const stream = canvas.captureStream();
            
            if (audioContext && soundToggle.checked) {
                const audioDestination = audioContext.createMediaStreamDestination();
                if (defaultSound) {
                    defaultSound.gainNode.connect(audioDestination);
                }
                const audioTracks = audioDestination.stream.getAudioTracks();
                audioTracks.forEach(track => stream.addTrack(track));
            }

            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9'
            });

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, {
                    type: 'video/webm'
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ball-simulation.webm';
                a.click();
                URL.revokeObjectURL(url);
                
                recordButton.textContent = 'Start Recording';
                recordButton.classList.remove('recording');
                recordingTimer.style.display = 'none';
                clearInterval(recordingInterval);
            };

            recordingStartTime = Date.now();
            mediaRecorder.start();
            recordButton.textContent = 'Stop Recording';
            recordButton.classList.add('recording');
            recordingTimer.style.display = 'block';
            
            recordingInterval = setInterval(updateRecordingTimer, 1000);

            const duration = parseInt(recordingDurationControl.value) * 1000;
            setTimeout(() => {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
            }, duration);
        }

        recordButton.onclick = () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            } else {
                startRecording();
            }
        };
        canvas.addEventListener('click', (e) => {
            if (!isPaused) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                let nearestBall = balls[0];
                let nearestDistance = Number.MAX_VALUE;
                
                balls.forEach(ball => {
                    const dx = x - ball.x;
                    const dy = y - ball.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearestBall = ball;
                    }
                });
                
                nearestBall.vx = (x - nearestBall.x) * 0.2;
                nearestBall.vy = (y - nearestBall.y) * 0.2;
                nearestBall.initialTotalEnergy = calculateTotalEnergy(nearestBall.y, nearestBall.vx, nearestBall.vy);
            }
        });
        const restartButton = document.getElementById('restartButton');
        const restartOnRecord = document.getElementById('restartOnRecord');

        function resetBalls() {
            const ballCount = parseInt(ballCountControl.value);
            balls = [];
            trailBalls = [];
            collisionLines = [];

            for (let i = 0; i < ballCount; i++) {
                const initialSpeed = parseFloat(initialSpeedControl.value);
                let vx, vy;
                
                if (directionMode.value === 'random') {
                    const angle = Math.random() * Math.PI * 2;
                    vx = Math.cos(angle) * initialSpeed;
                    vy = Math.sin(angle) * initialSpeed;
                } else {
                    vx = initialSpeed;
                    vy = 0;
                }

                const angle = (i / ballCount) * Math.PI * 2;
                const radius = ringRadius * 0.75;
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;

                const ball = {
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    radius: ballRadius,
                    hasCollidedWithWall: false,
                    initialTotalEnergy: 0,
                    color: getCurrentColor(),
                    trails: []
                };
                ball.initialTotalEnergy = calculateTotalEnergy(ball.y, ball.vx, ball.vy);
                balls.push(ball);
            }
        }

        resetBalls();

        restartButton.onclick = () => {
            resetBalls();
        };
    </script>
</body>
</html>